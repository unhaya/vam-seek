<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAM Seek - 2D„Ç∑„Éº„ÇØ„Éû„Éº„Ç´„Éº „Éá„É¢</title>
    <style>
        :root {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252526;
            --bg-tertiary: #2d2d30;
            --border-color: #3c3c3c;
            --accent: #8b5cf6;
            --highlight: #e94560;
            --text: #cccccc;
            --text-dim: #808080;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif;
            background: var(--bg-primary);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 32px);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Â∑¶„Éë„Éç„É´ */
        .left-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .left-panel.collapsed {
            width: 40px;
        }

        .left-panel.collapsed .upload-area,
        .left-panel.collapsed .video-list,
        .left-panel.collapsed .panel-title {
            display: none;
        }

        .left-panel.collapsed .panel-header {
            padding: 12px 8px;
            justify-content: center;
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .panel-toggle:hover {
            background: var(--bg-primary);
        }

        .upload-area {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .upload-dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-dropzone:hover,
        .upload-dropzone.dragover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .upload-icon { font-size: 40px; margin-bottom: 12px; }
        .upload-text { font-size: 13px; color: var(--text-dim); line-height: 1.6; }

        .video-list { flex: 1; overflow-y: auto; padding: 8px 0; }

        .video-item {
            padding: 10px 16px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            border-left: 3px solid transparent;
            transition: background 0.2s;
        }

        .video-item:hover { background: var(--bg-tertiary); }
        .video-item.selected { background: var(--accent); border-left-color: var(--highlight); }
        .video-item-icon { font-size: 18px; }
        .video-item-info { flex: 1; overflow: hidden; }
        .video-item-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .video-item-duration { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

        /* ‰∏≠Â§Æ„Ç®„É™„Ç¢ */
        .main-area {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .player-area {
            flex: 0 0 auto;
            height: 50%;
            min-height: 200px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-area {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--border-color);
        }

        .player-placeholder {
            color: var(--text-dim);
            font-size: 15px;
            text-align: center;
            line-height: 1.8;
        }

        #videoPlayer {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
        }

        #videoPlayer.visible { display: block; }

        .control-bar {
            height: 48px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 16px;
        }

        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .btn:hover { background: var(--accent); border-color: var(--accent); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-primary { background: var(--accent); border-color: var(--accent); }

        .time-display {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
        }

        .time-current { color: var(--highlight); font-weight: bold; }

        /* „Ç∞„É™„ÉÉ„Éâ„Éë„Éç„É´ÔºàÂãïÁîª„ÅÆ‰∏ã„Å´Ë°®Á§∫Ôºâ */
        .grid-panel {
            flex: 1;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            min-height: 0;
            transition: flex 0.3s ease, min-height 0.3s ease;
        }

        .grid-panel.collapsed {
            flex: 0 0 40px;
            min-height: 40px;
        }

        .grid-panel.collapsed .grid-container {
            display: none;
        }

        .grid-panel.collapsed .grid-settings {
            display: none;
        }

        .grid-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .grid-toggle:hover {
            background: var(--bg-primary);
        }

        .grid-header {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .grid-settings {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .grid-label { color: var(--text-dim); font-size: 11px; }

        .grid-select {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text);
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
        }

        .grid-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: var(--bg-primary);
        }

        .grid-scroll-wrapper {
            position: relative;
            width: 100%;
        }

        .thumbnail-grid {
            display: grid;
            gap: 2px;
            background: var(--border-color);
        }

        .grid-cell {
            aspect-ratio: 16/9;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }

        .grid-cell img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .grid-cell img.loaded { opacity: 1; }

        .cell-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .grid-cell.loaded .cell-loader { display: none; }

        .cell-time {
            position: absolute;
            bottom: 2px;
            right: 4px;
            background: rgba(0,0,0,0.75);
            padding: 2px 6px;
            font-size: 10px;
            border-radius: 3px;
            pointer-events: none;
        }

        /* „Éû„Éº„Ç´„Éº */
        .svg-marker {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            display: none;
            will-change: transform;
        }

        .svg-marker svg {
            width: 100%;
            height: 100%;
        }

        /* ÊÉÖÂ†±„Éï„ÉÉ„Çø„ÉºÔºà„Ç∞„É™„ÉÉ„Éâ„Éë„Éç„É´‰∏ãÈÉ®Âõ∫ÂÆöÔºâ */
        .info-footer {
            flex: 0 0 auto;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'Consolas', monospace;
            display: none;
        }

        .info-footer.visible {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label { color: var(--text-dim); }
        .info-value { color: var(--highlight); font-weight: bold; }

        /* „É≠„Éº„Éá„Ç£„É≥„Ç∞ */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            flex-direction: column;
            gap: 16px;
        }

        .loading-overlay.visible { display: flex; }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* „Çπ„ÉÜ„Éº„Çø„Çπ„Éê„Éº */
        .status-bar {
            height: 32px;
            background: var(--accent);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 12px;
            gap: 24px;
        }

        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-key {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-family: monospace;
        }

        #fileInput { display: none; }

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #4a4a4a; }

        /* Tablet - Â∑¶„Éë„Éç„É´ÈùûË°®Á§∫ */
        @media (max-width: 1024px) {
            .left-panel { display: none; }
        }

        /* Mobile - Á∏¶‰∏¶„Å≥„É¨„Ç§„Ç¢„Ç¶„Éà */
        @media (max-width: 768px) {
            body {
                height: 100vh;
                overflow: hidden;
            }
            .app-container {
                flex-direction: column;
                height: calc(100vh - 40px);
            }
            .main-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }
            /* ÂãïÁîª„Ç®„É™„Ç¢‰∏äÈÉ®Âõ∫ÂÆö */
            .player-area {
                flex: 0 0 auto;
                height: 35vh;
                min-height: 180px;
                max-height: 280px;
            }
            .control-bar {
                flex: 0 0 auto;
                flex-wrap: wrap;
                height: auto;
                padding: 6px 10px;
                gap: 6px;
            }
            /* „Ç∞„É™„ÉÉ„Éâ„Ç®„É™„Ç¢„Åå„Çπ„ÇØ„É≠„Éº„É´ */
            .grid-panel {
                flex: 1;
                min-height: 0;
                overflow: hidden;
            }
            .grid-container {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            .grid-header {
                flex: 0 0 auto;
                flex-wrap: wrap;
                gap: 6px;
                padding: 6px 10px;
            }
            .grid-settings {
                width: 100%;
                justify-content: space-between;
            }
            .status-bar {
                height: 40px;
                padding: 0 10px;
                gap: 12px;
            }
        }

        /* Mobile Portrait - „Åï„Çâ„Å´Â∞è„Åï„ÅÑÁîªÈù¢ */
        @media (max-width: 480px) {
            .player-area {
                height: 30vh;
                min-height: 160px;
                max-height: 220px;
            }
            .grid-header {
                font-size: 11px;
            }
            .grid-settings {
                gap: 4px;
            }
            .grid-select {
                padding: 4px 6px;
                font-size: 11px;
            }
            .grid-label {
                font-size: 10px;
            }
            .btn {
                padding: 5px 8px;
                font-size: 11px;
            }
            .time-display {
                font-size: 11px;
            }
            .status-bar {
                font-size: 10px;
                height: 36px;
            }
            .status-key {
                padding: 2px 4px;
                font-size: 9px;
            }
            .cell-time {
                font-size: 8px;
                padding: 1px 3px;
            }
            .info-footer {
                font-size: 10px;
                padding: 6px 10px;
            }
        }

        /* „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÊúÄÈÅ©Âåñ */
        @media (hover: none) and (pointer: coarse) {
            .grid-cell {
                min-height: 50px;
            }
            .btn {
                min-height: 40px;
                min-width: 40px;
            }
            .grid-select {
                min-height: 32px;
            }
            .upload-dropzone {
                padding: 20px 12px;
            }
            /* „Çπ„É†„Éº„Ç∫„Çπ„ÇØ„É≠„Éº„É´ */
            .grid-container {
                scroll-behavior: smooth;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Â∑¶„Éë„Éç„É´ -->
        <div class="left-panel" id="leftPanel">
            <div class="panel-header">
                <button type="button" class="panel-toggle" id="leftPanelToggle" title="„Éë„Éç„É´„ÇíÊäò„Çä„Åü„Åü„ÇÄ">‚óÄ</button>
                <span class="panel-title">ÂãïÁîª‰∏ÄË¶ß</span>
            </div>
            <div class="upload-area">
                <div class="upload-dropzone" id="uploadDropzone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">
                        ÂãïÁîª„Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó<br>
                        „Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÈÅ∏Êäû<br>
                        <small style="color: #666">‚Äª„É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„ÇíÁõ¥Êé•Ë™≠„ÅøËæº„ÅøÔºà„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏çË¶ÅÔºâ</small>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="video/*">
            </div>
            <div class="video-list" id="videoList"></div>
        </div>

        <!-- „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„É≥„ÉÑÔºàÂãïÁîª + „Ç∞„É™„ÉÉ„ÉâÁ∏¶‰∏¶„Å≥Ôºâ -->
        <div class="main-area">
            <!-- ÂãïÁîª„Ç®„É™„Ç¢ -->
            <div class="player-area" id="playerArea">
                <div class="player-placeholder" id="playerPlaceholder">
                    ÂãïÁîª„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ<br>
                    <small>MP4, WebM, MOV ÂØæÂøú</small><br>
                    <small style="color: #888">‚ÄªÂÆåÂÖ®„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂá¶ÁêÜÔºà„Çµ„Éº„Éê„Éº„Å∏„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å™„ÅóÔºâ</small>
                </div>
                <video id="videoPlayer" controls playsinline></video>
            </div>
            <div class="control-bar">
                <button type="button" class="btn" id="playBtn" disabled>‚ñ∂ ÂÜçÁîü</button>
                <div class="time-display">
                    <span class="time-current" id="currentTime">00:00.00</span>
                    <span> / </span>
                    <span id="totalTime">00:00.00</span>
                </div>
                <div style="flex:1"></div>
                <span style="font-size: 12px; color: var(--text-dim)">
                    „Ç∞„É™„ÉÉ„Éâ: <span id="gridSizeDisplay">--</span>
                </span>
            </div>

            <!-- „Ç∞„É™„ÉÉ„Éâ„Ç®„É™„Ç¢ÔºàÂãïÁîª„ÅÆ‰∏ãÔºâ -->
            <div class="grid-panel" id="gridPanel">
            <div class="grid-header">
                <button type="button" class="grid-toggle" id="gridToggle" title="„Ç∞„É™„ÉÉ„Éâ„ÇíÊäò„Çä„Åü„Åü„ÇÄ">‚ñº</button>
                <span class="grid-title">„Çµ„É†„Éç„Ç§„É´„Ç∞„É™„ÉÉ„Éâ</span>
                <div class="grid-settings">
                    <span class="grid-label">Âàó:</span>
                    <select class="grid-select" id="columnsSelect">
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="8">8</option>
                    </select>
                    <span class="grid-label">Áßí/„Çª„É´:</span>
                    <select class="grid-select" id="intervalSelect">
                        <option value="5" selected>5s</option>
                        <option value="10">10s</option>
                        <option value="15">15s</option>
                        <option value="30">30s</option>
                        <option value="60">1m</option>
                    </select>
                    <button type="button" class="btn btn-primary" id="regenerateBtn" disabled>ÁîüÊàê</button>
                </div>
            </div>
            <div class="grid-container" id="gridContainer">
                <div class="grid-scroll-wrapper" id="gridScrollWrapper">
                    <div class="thumbnail-grid" id="thumbnailGrid"></div>
                    <div class="svg-marker" id="svgMarker">
                        <svg viewBox="0 0 155.91 155.91">
                            <circle cx="77.95" cy="77.95" r="63.49" fill="#b7392b" stroke="#fff" stroke-miterlimit="10" stroke-width="8"/>
                            <path fill="#fff" d="M66.6,109.32c-5.24,3.39-9.52,1.05-9.52-5.18v-52.38c0-6.24,4.28-8.57,9.52-5.18l38.99,25.21c5.24,3.39,5.24,8.93,0,12.31l-38.99,25.21Z"/>
                        </svg>
                    </div>
                </div>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div id="loadingText">„Éï„É¨„Éº„É†ÊäΩÂá∫‰∏≠...</div>
                </div>
            </div>
            <div class="info-footer" id="infoFooter">
                <div class="info-item">
                    <span class="info-label">ÊôÇÈñì:</span>
                    <span class="info-value" id="overlayTime">00:00.00</span>
                </div>
                <div class="info-item">
                    <span class="info-label">„Çª„É´:</span>
                    <span class="info-value" id="overlayCell">(0, 0)</span>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item"><span class="status-key">„Çø„ÉÉ„ÉÅ/„Éâ„É©„ÉÉ„Ç∞</span> „Ç∑„Éº„ÇØ</div>
        <div class="status-item"><span class="status-key">‚Üë‚Üì‚Üê‚Üí</span> „Éû„Éº„Ç´„ÉºÁßªÂãï</div>
        <div style="flex:1"></div>
        <div class="status-item" style="color: rgba(255,255,255,0.8)">2D Seek Bar</div>
    </div>

    <script>
        // ==================================================
        // VAM Seek - Static Demo (No Server Required)
        // ==================================================

        // Configuration
        const CONFIG = {
            columns: 3,
            secondsPerCell: 5,
            thumbWidth: 160,
            thumbHeight: 90,
            videoDuration: 0
        };

        // State
        const STATE = {
            totalRows: 0,
            totalCells: 0,
            gridWidth: 0,
            gridHeight: 0,
            cellWidth: 0,
            cellHeight: 0,
            markerX: 0,
            markerY: 0,
            targetX: 0,
            targetY: 0,
            currentCellX: 0,
            currentCellY: 0,
            isDragging: false,
            isAnimating: false,
            animationId: null,
            videos: [],
            currentVideoUrl: null,
            frameExtractorVideo: null,
            isExtracting: false,
            aborted: false
        };

        // LRU Cache (Video-aware)
        // [2025-01-13] ÂãïÁîªÂçò‰Ωç„Åß„Ç≠„É£„ÉÉ„Ç∑„É•ÁÆ°ÁêÜ + LRUÊñπÂºè„ÅßÊúÄÂ§ßNÊú¨„ÅÆÂãïÁîª„Çí‰øùÊåÅ
        class FrameCache {
            constructor(maxFramesPerVideo = 200, maxVideos = 3) {
                this.caches = new Map(); // videoUrl -> Map(timestamp -> dataUrl)
                this.maxFramesPerVideo = maxFramesPerVideo;
                this.maxVideos = maxVideos;
                this.currentVideoUrl = null;
            }

            /**
             * ÁèæÂú®„ÅÆÂãïÁîª„ÇíË®≠ÂÆöÔºàÂãïÁîªÂàá„ÇäÊõø„ÅàÊôÇ„Å´Âëº„Å∂Ôºâ
             * LRUÊñπÂºè: Êó¢Â≠òÂãïÁîª„Å™„ÇâÊúÄÊñ∞„Å´ÁßªÂãï„ÄÅÊñ∞Ë¶èÂãïÁîª„Å™„ÇâÂè§„ÅÑÂãïÁîª„ÇíÂâäÈô§
             */
            setCurrentVideo(videoUrl) {
                if (!videoUrl) return;

                const videoShortName = videoUrl.substring(videoUrl.lastIndexOf('/') + 1, videoUrl.lastIndexOf('/') + 20);

                this.currentVideoUrl = videoUrl;

                // Êó¢Â≠ò„ÅÆÂãïÁîª„Å™„ÇâÊúÄÊñ∞„Å´ÁßªÂãïÔºàLRUÔºâ
                if (this.caches.has(videoUrl)) {
                    const cache = this.caches.get(videoUrl);
                    this.caches.delete(videoUrl);
                    this.caches.set(videoUrl, cache);
                    console.log(`[FrameCache] ÂãïÁîªÂàá„ÇäÊõø„Åà (Êó¢Â≠ò): ${videoShortName}... (${cache.size}„Éï„É¨„Éº„É†„Ç≠„É£„ÉÉ„Ç∑„É•Ê∏à„Åø)`);
                    return;
                }

                // Êñ∞Ë¶èÂãïÁîª: ‰∏äÈôê„ÉÅ„Çß„ÉÉ„ÇØ
                if (this.caches.size >= this.maxVideos) {
                    // ÊúÄ„ÇÇÂè§„ÅÑÂãïÁîªÔºàÊúÄÂàù„ÅÆ„Ç®„É≥„Éà„É™Ôºâ„ÇíÂâäÈô§
                    const oldestUrl = this.caches.keys().next().value;
                    const oldestShortName = oldestUrl.substring(oldestUrl.lastIndexOf('/') + 1, oldestUrl.lastIndexOf('/') + 20);
                    this.caches.delete(oldestUrl);
                    console.log(`[FrameCache] LRUÂâäÈô§: ${oldestShortName}...`);
                }

                // Êñ∞„Åó„ÅÑÂãïÁîªÁî®„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê
                this.caches.set(videoUrl, new Map());
                console.log(`[FrameCache] ÂãïÁîªÂàá„ÇäÊõø„Åà (Êñ∞Ë¶è): ${videoShortName}... („Ç≠„É£„ÉÉ„Ç∑„É•Êï∞: ${this.caches.size}/${this.maxVideos})`);
            }

            /**
             * „Éï„É¨„Éº„É†„ÇíÂèñÂæóÔºàLRUÊõ¥Êñ∞Ôºâ
             */
            get(ts) {
                if (!this.currentVideoUrl) return null;

                const cache = this.caches.get(this.currentVideoUrl);
                if (!cache) return null;

                const key = ts.toFixed(2);
                if (!cache.has(key)) return null;

                // LRU: ÊúÄÊñ∞„Å´ÁßªÂãï
                const value = cache.get(key);
                cache.delete(key);
                cache.set(key, value);
                return value;
            }

            /**
             * „Éï„É¨„Éº„É†„Çí‰øùÂ≠òÔºàLRU„ÄÅ„Çµ„Ç§„Ç∫Âà∂Èôê„ÅÇ„ÇäÔºâ
             */
            put(ts, data) {
                if (!this.currentVideoUrl || !data) return;

                const cache = this.caches.get(this.currentVideoUrl);
                if (!cache) return;

                const key = ts.toFixed(2);

                // Êó¢Â≠ò„Ç≠„Éº„Å™„ÇâÂâäÈô§„Åó„Å¶ÊúÄÊñ∞„Å´
                if (cache.has(key)) {
                    cache.delete(key);
                } else if (cache.size >= this.maxFramesPerVideo) {
                    // „Çµ„Ç§„Ç∫‰∏äÈôê: ÊúÄÂè§„ÅÆ„Éï„É¨„Éº„É†„ÇíÂâäÈô§
                    const oldestKey = cache.keys().next().value;
                    cache.delete(oldestKey);
                }

                cache.set(key, data);
            }

            /**
             * ÁèæÂú®„ÅÆÂãïÁîª„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
             */
            clearCurrentVideo() {
                if (this.currentVideoUrl && this.caches.has(this.currentVideoUrl)) {
                    this.caches.delete(this.currentVideoUrl);
                }
            }

            /**
             * ÂÖ®ÂãïÁîª„ÅÆ„Ç≠„É£„ÉÉ„Ç∑„É•„Çí„ÇØ„É™„Ç¢
             */
            clearAll() {
                this.caches.clear();
                this.currentVideoUrl = null;
            }

            /**
             * „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±
             */
            getStats() {
                const stats = {
                    totalVideos: this.caches.size,
                    currentVideo: this.currentVideoUrl,
                    videos: []
                };

                for (const [url, cache] of this.caches.entries()) {
                    stats.videos.push({
                        url: url.substring(0, 50) + '...',
                        frames: cache.size
                    });
                }

                return stats;
            }
        }

        const frameCache = new FrameCache(200, 3);

        // DOM Elements
        const $ = id => document.getElementById(id);
        const elements = {
            uploadDropzone: $('uploadDropzone'),
            fileInput: $('fileInput'),
            videoList: $('videoList'),
            videoPlayer: $('videoPlayer'),
            playerPlaceholder: $('playerPlaceholder'),
            playBtn: $('playBtn'),
            currentTime: $('currentTime'),
            totalTime: $('totalTime'),
            gridSizeDisplay: $('gridSizeDisplay'),
            columnsSelect: $('columnsSelect'),
            intervalSelect: $('intervalSelect'),
            regenerateBtn: $('regenerateBtn'),
            gridContainer: $('gridContainer'),
            thumbnailGrid: $('thumbnailGrid'),
            svgMarker: $('svgMarker'),
            infoFooter: $('infoFooter'),
            overlayTime: $('overlayTime'),
            overlayCell: $('overlayCell'),
            loadingOverlay: $('loadingOverlay'),
            loadingText: $('loadingText'),
            gridPanel: $('gridPanel'),
            gridToggle: $('gridToggle'),
            leftPanel: $('leftPanel'),
            leftPanelToggle: $('leftPanelToggle')
        };

        // ==================================================
        // Grid Calculation (Client-side, No Server API)
        // ==================================================

        function calculateGridConfig(videoDuration, columns, secondsPerCell) {
            const totalCells = Math.ceil(videoDuration / secondsPerCell);
            const rows = Math.ceil(totalCells / columns);
            return { rows, columns, totalCells, secondsPerCell, videoDuration };
        }

        // ==================================================
        // File Loading (No Server Upload Required)
        // ==================================================

        function handleFileSelect(file) {
            if (!file || !file.type.startsWith('video/')) {
                alert('Please select a video file');
                return;
            }

            const url = URL.createObjectURL(file);
            const videoData = {
                id: Date.now().toString(),
                name: file.name,
                url: url,
                duration: 0
            };

            // Get video duration
            const tempVideo = document.createElement('video');
            tempVideo.src = url;
            tempVideo.addEventListener('loadedmetadata', () => {
                videoData.duration = tempVideo.duration;
                STATE.videos.push(videoData);
                renderVideoList();
                selectVideo(videoData.id);
            });
        }

        function renderVideoList() {
            elements.videoList.innerHTML = '';
            STATE.videos.forEach(v => {
                const item = document.createElement('div');
                item.className = 'video-item' + (STATE.currentVideoUrl === v.url ? ' selected' : '');
                item.dataset.id = v.id;

                const icon = document.createElement('span');
                icon.className = 'video-item-icon';
                icon.textContent = 'üé¨';

                const info = document.createElement('div');
                info.className = 'video-item-info';

                const name = document.createElement('div');
                name.className = 'video-item-name';
                name.textContent = v.name;

                const duration = document.createElement('div');
                duration.className = 'video-item-duration';
                duration.textContent = formatTime(v.duration);

                info.appendChild(name);
                info.appendChild(duration);
                item.appendChild(icon);
                item.appendChild(info);
                item.addEventListener('click', () => selectVideo(v.id));
                elements.videoList.appendChild(item);
            });
        }

        // [2025-01-13] ÂãïÁîªÂàá„ÇäÊõø„ÅàÊôÇ: Âá¶ÁêÜ‰∏≠Êñ≠ + LRU„Ç≠„É£„ÉÉ„Ç∑„É•Êõ¥Êñ∞
        function selectVideo(id) {
            const video = STATE.videos.find(v => v.id === id);
            if (!video) return;

            // Êó¢„Å´Âêå„ÅòÂãïÁîª„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åü„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
            if (STATE.currentVideoUrl === video.url) return;

            console.log(`[selectVideo] ÂãïÁîªÂàá„ÇäÊõø„Åà: ${video.name}`);

            // ÈÄ≤Ë°å‰∏≠„ÅÆ„Éï„É¨„Éº„É†ÊäΩÂá∫Âá¶ÁêÜ„Çí‰∏≠Êñ≠
            STATE.aborted = true;

            // Êñ∞„Åó„ÅÑÂãïÁîªURL„ÇíË®≠ÂÆö
            STATE.currentVideoUrl = video.url;

            // FrameCache„Å´ÁèæÂú®„ÅÆÂãïÁîª„ÇíÈÄöÁü•ÔºàLRUÊõ¥Êñ∞Ôºâ
            frameCache.setCurrentVideo(video.url);

            // ÂãïÁîª„Éó„É¨„Ç§„É§„Éº„ÇíÊõ¥Êñ∞
            elements.videoPlayer.src = video.url;
            elements.videoPlayer.classList.add('visible');
            elements.playerPlaceholder.style.display = 'none';
            elements.playBtn.disabled = false;
            elements.regenerateBtn.disabled = false;

            // „É°„Çø„Éá„Éº„ÇøË™≠„ÅøËæº„ÅøÂÆå‰∫ÜÂæå„Å´„Çµ„É†„Éç„Ç§„É´ÁîüÊàêÈñãÂßã
            elements.videoPlayer.addEventListener('loadedmetadata', () => {
                CONFIG.videoDuration = elements.videoPlayer.duration;
                elements.totalTime.textContent = formatTime(CONFIG.videoDuration);
                generateThumbnails();
            }, { once: true });

            // ÂãïÁîª„É™„Çπ„Éà„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„ÇíÊõ¥Êñ∞
            renderVideoList();
        }

        // ==================================================
        // Thumbnail Generation (Full Client-side Processing)
        // ==================================================

        // [2025-01-13] „Ç∞„É™„ÉÉ„ÉâÁîüÊàê: ÂâçÂõû„ÅÆÂá¶ÁêÜ„ÇíÁ¢∫ÂÆü„Å´‰∏≠Êñ≠„Åó„Å¶„Åã„ÇâÈñãÂßã
        async function generateThumbnails() {
            if (!STATE.currentVideoUrl) return;

            // ÂâçÂõû„ÅÆÂá¶ÁêÜ„Çí‰∏≠Êñ≠Ôºà„ÅÇ„Çå„Å∞Ôºâ
            STATE.aborted = true;

            // Âá¶ÁêÜ„ÅåÂÆåÂÖ®„Å´ÂÅúÊ≠¢„Åô„Çã„Åæ„ÅßÂæÖÊ©üÔºàisExtracting„Éï„É©„Ç∞„ÅåËß£Êîæ„Åï„Çå„Çã„Åæ„ÅßÔºâ
            let waitCount = 0;
            while (STATE.isExtracting && waitCount < 50) {
                await new Promise(r => setTimeout(r, 10));
                waitCount++;
            }

            // Âº∑Âà∂ÁöÑ„Å´„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„ÉàÔºàÂøµ„ÅÆ„Åü„ÇÅÔºâ
            if (STATE.isExtracting) {
                console.warn('[generateThumbnails] Âº∑Âà∂ÁöÑ„Å´isExtracting„Çí„É™„Çª„ÉÉ„Éà');
                STATE.isExtracting = false;
            }

            // „Ç∞„É™„ÉÉ„ÉâË®≠ÂÆö„ÇíÂèñÂæó
            CONFIG.columns = parseInt(elements.columnsSelect.value);
            CONFIG.secondsPerCell = parseInt(elements.intervalSelect.value);

            showLoading('„Ç∞„É™„ÉÉ„ÉâÁîüÊàê‰∏≠...');

            const config = calculateGridConfig(
                CONFIG.videoDuration,
                CONFIG.columns,
                CONFIG.secondsPerCell
            );

            STATE.totalRows = config.rows;
            STATE.totalCells = config.totalCells;

            elements.gridSizeDisplay.textContent = `${CONFIG.columns}√ó${STATE.totalRows}`;

            // „Ç∞„É™„ÉÉ„Éâ„ÇíÂÜçÁîüÊàê
            renderGrid();
            hideLoading();

            // „Éû„Éº„Ç´„ÉºÂàùÊúüÂåñ„Å®„Éï„É¨„Éº„É†ÊäΩÂá∫ÈñãÂßã
            requestAnimationFrame(() => {
                updateGridDimensions();
                initializeMarker();
                elements.infoFooter.classList.add('visible');
                extractAllFrames();
            });
        }

        function renderGrid() {
            const grid = elements.thumbnailGrid;
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${CONFIG.columns}, 1fr)`;

            for (let i = 0; i < STATE.totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.index = i;

                const loader = document.createElement('div');
                loader.className = 'cell-loader';
                cell.appendChild(loader);

                const time = i * CONFIG.secondsPerCell;
                const label = document.createElement('span');
                label.className = 'cell-time';
                label.textContent = formatTimeShort(time);
                cell.appendChild(label);

                grid.appendChild(cell);
            }
        }

        // ==================================================
        // Frame Extraction
        // ==================================================

        // [2025-01-13] ÂãïÁîªURLÂçò‰Ωç„ÅßÂá¶ÁêÜ„ÇíÁÆ°ÁêÜ„Åó„ÄÅÂãïÁîªÂàá„ÇäÊõø„ÅàÊôÇ„Å´Á¢∫ÂÆü„Å´‰∏≠Êñ≠
        async function extractAllFrames() {
            if (!STATE.currentVideoUrl) return;

            // Êó¢„Å´Âá¶ÁêÜ‰∏≠„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºàÁ´∂ÂêàÈò≤Ê≠¢Ôºâ
            if (STATE.isExtracting) return;

            STATE.isExtracting = true;
            STATE.aborted = false;

            // „Åì„ÅÆÂá¶ÁêÜ„ÅåÂØæË±°„Å®„Åô„ÇãÂãïÁîªURL„ÇíË®òÊÜ∂ÔºàÂá¶ÁêÜ‰∏≠„Å´Âàá„ÇäÊõø„Çè„Å£„Åü„ÅãÊ§úÂá∫„Åô„Çã„Åü„ÇÅÔºâ
            const targetVideoUrl = STATE.currentVideoUrl;
            console.log(`[extractAllFrames] ÈñãÂßã: ${STATE.totalCells}„Éï„É¨„Éº„É†ÊäΩÂá∫`);

            try {
                // Âè§„ÅÑÊäΩÂá∫Áî®videoË¶ÅÁ¥†„ÇíÂâäÈô§
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.remove();
                    STATE.frameExtractorVideo = null;
                }

                // Êñ∞„Åó„ÅÑÊäΩÂá∫Áî®videoË¶ÅÁ¥†„Çí‰ΩúÊàê
                STATE.frameExtractorVideo = await createExtractorVideo(targetVideoUrl);

                for (let i = 0; i < STATE.totalCells; i++) {
                    // ‰∏≠Êñ≠Êù°‰ª∂1: aborted„Éï„É©„Ç∞
                    if (STATE.aborted) {
                        console.log(`[extractAllFrames] ‰∏≠Êñ≠ (aborted): ${i}/${STATE.totalCells}„Éï„É¨„Éº„É†ÂÆå‰∫Ü`);
                        break;
                    }

                    // ‰∏≠Êñ≠Êù°‰ª∂2: ÂãïÁîª„ÅåÂàá„ÇäÊõø„Çè„Å£„ÅüÔºàÈáçË¶ÅÔºÅÔºâ
                    if (STATE.currentVideoUrl !== targetVideoUrl) {
                        console.log(`[extractAllFrames] ‰∏≠Êñ≠ (ÂãïÁîªÂàá„ÇäÊõø„Åà): ${i}/${STATE.totalCells}„Éï„É¨„Éº„É†ÂÆå‰∫Ü`);
                        break;
                    }

                    // Extract thumbnail from center of cell (0.5 offset)
                    const timestamp = (i + 0.5) * CONFIG.secondsPerCell;
                    const cell = elements.thumbnailGrid.children[i];
                    if (!cell) continue;

                    // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
                    const cached = frameCache.get(timestamp);
                    if (cached) {
                        displayFrame(cell, cached);
                        continue;
                    }

                    // „Éï„É¨„Éº„É†ÊäΩÂá∫
                    const frame = await extractFrame(STATE.frameExtractorVideo, timestamp);

                    // ÊäΩÂá∫ÂÆå‰∫ÜÂæå„ÄÅÂÜçÂ∫¶‰∏≠Êñ≠„ÉÅ„Çß„ÉÉ„ÇØÔºàÂãïÁîªÂàá„ÇäÊõø„Çè„Çä„ÇÑabort„ÇíÊ§úÂá∫Ôºâ
                    if (frame && !STATE.aborted && STATE.currentVideoUrl === targetVideoUrl) {
                        frameCache.put(timestamp, frame);
                        displayFrame(cell, frame);
                    }

                    // CPUË≤†Ëç∑ËªΩÊ∏õ„ÅÆ„Åü„ÇÅÁü≠ÊôÇÈñìÂæÖÊ©ü
                    await new Promise(r => setTimeout(r, 5));
                }

                // Ê≠£Â∏∏ÂÆå‰∫Ü
                if (!STATE.aborted && STATE.currentVideoUrl === targetVideoUrl) {
                    console.log(`[extractAllFrames] ÂÆå‰∫Ü: ${STATE.totalCells}/${STATE.totalCells}„Éï„É¨„Éº„É†`);
                }
            } catch (e) {
                // Frame extraction error - silently fail
                console.error('[extractAllFrames] Error:', e);
            } finally {
                STATE.isExtracting = false;

                // ÊäΩÂá∫Áî®videoË¶ÅÁ¥†„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
                if (STATE.frameExtractorVideo) {
                    STATE.frameExtractorVideo.remove();
                    STATE.frameExtractorVideo = null;
                }
            }
        }

        function createExtractorVideo(url) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.style.display = 'none';
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';
                if (url.startsWith('http') && !url.startsWith(location.origin)) {
                    video.crossOrigin = 'anonymous';
                }
                video.src = url;

                const onReady = () => {
                    video.removeEventListener('loadeddata', onReady);
                    video.removeEventListener('canplay', onReady);
                    resolve(video);
                };

                video.addEventListener('loadeddata', onReady);
                video.addEventListener('canplay', onReady);
                video.addEventListener('error', reject);

                setTimeout(() => {
                    video.removeEventListener('loadeddata', onReady);
                    video.removeEventListener('canplay', onReady);
                    if (video.readyState >= 2) {
                        resolve(video);
                    } else {
                        reject(new Error('Video load timeout'));
                    }
                }, 10000);

                document.body.appendChild(video);
                video.load();
            });
        }

        function extractFrame(video, timestamp) {
            return new Promise(resolve => {
                if (Math.abs(video.currentTime - timestamp) < 0.1 && video.readyState >= 2) {
                    resolve(captureFrame(video));
                    return;
                }

                let resolved = false;

                const onSeeked = () => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    setTimeout(() => resolve(captureFrame(video)), 50);
                };

                video.addEventListener('seeked', onSeeked);
                video.currentTime = Math.min(timestamp, video.duration - 0.1);

                setTimeout(() => {
                    if (resolved) return;
                    resolved = true;
                    video.removeEventListener('seeked', onSeeked);
                    resolve(captureFrame(video));
                }, 5000);
            });
        }

        function captureFrame(video) {
            if (video.readyState < 2) return null;
            try {
                const canvas = document.createElement('canvas');
                canvas.width = CONFIG.thumbWidth;
                canvas.height = CONFIG.thumbHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas.toDataURL('image/jpeg', 0.8);
            } catch (e) {
                return null;
            }
        }

        function displayFrame(cell, dataUrl) {
            const loader = cell.querySelector('.cell-loader');
            if (loader) loader.remove();

            const existing = cell.querySelector('img');
            if (existing) existing.remove();

            const img = new Image();
            img.onload = () => {
                cell.insertBefore(img, cell.firstChild);
                requestAnimationFrame(() => img.classList.add('loaded'));
                cell.classList.add('loaded');
            };
            img.src = dataUrl;
        }

        // ==================================================
        // Marker
        // ==================================================

        function updateGridDimensions() {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();
            STATE.gridWidth = rect.width;
            STATE.gridHeight = rect.height;

            // Get actual cell size (accounting for gap)
            const firstCell = grid.querySelector('.grid-cell');
            if (firstCell) {
                const cellRect = firstCell.getBoundingClientRect();
                STATE.cellWidth = cellRect.width;
                STATE.cellHeight = cellRect.height;

                // Calculate gap
                const gridStyle = getComputedStyle(grid);
                STATE.gridGap = parseFloat(gridStyle.gap) || 2;
            } else {
                STATE.cellWidth = rect.width / CONFIG.columns;
                STATE.cellHeight = rect.height / STATE.totalRows;
                STATE.gridGap = 2;
            }
        }

        function initializeMarker() {
            STATE.markerSize = Math.max(24, Math.min(STATE.cellWidth, STATE.cellHeight) * 0.42);
            elements.svgMarker.style.display = 'block';
            elements.svgMarker.style.width = `${STATE.markerSize}px`;
            elements.svgMarker.style.height = `${STATE.markerSize}px`;

            STATE.markerX = 0;
            STATE.markerY = STATE.cellHeight / 2;
            STATE.targetX = STATE.markerX;
            STATE.targetY = STATE.markerY;
            updateMarkerPosition();
        }

        function updateMarkerPosition() {
            const offsetX = STATE.markerSize / 2;
            const offsetY = STATE.markerSize / 2;
            elements.svgMarker.style.transform = `translate(${STATE.markerX - offsetX}px, ${STATE.markerY - offsetY}px)`;
        }

        function moveMarkerTo(x, y, animate = true) {
            STATE.targetX = Math.max(0, Math.min(x, STATE.gridWidth));
            STATE.targetY = Math.max(0, Math.min(y, STATE.gridHeight));

            if (animate && !STATE.isAnimating) {
                STATE.isAnimating = true;
                animateMarker();
            } else if (!animate) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                updateMarkerPosition();
            }
        }

        function animateMarker() {
            const dx = STATE.targetX - STATE.markerX;
            const dy = STATE.targetY - STATE.markerY;

            if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                STATE.markerX = STATE.targetX;
                STATE.markerY = STATE.targetY;
                STATE.isAnimating = false;
                updateMarkerPosition();
                return;
            }

            STATE.markerX += dx * 0.15;
            STATE.markerY += dy * 0.15;
            updateMarkerPosition();

            STATE.animationId = requestAnimationFrame(animateMarker);
        }

        function calculateMarkerPositionFromTime(currentTime) {
            if (STATE.totalCells === 0 || CONFIG.secondsPerCell <= 0) {
                return { x: 0, y: STATE.cellHeight / 2 };
            }

            const gap = STATE.gridGap || 2;
            const continuousCellIndex = currentTime / CONFIG.secondsPerCell;
            let row = Math.floor(continuousCellIndex / CONFIG.columns);
            row = Math.max(0, Math.min(row, STATE.totalRows - 1));

            const positionInRow = continuousCellIndex - (row * CONFIG.columns);
            const col = Math.floor(positionInRow);
            const colFraction = positionInRow - col;

            // X position (account for gap)
            const cellPlusGapX = STATE.cellWidth + gap;
            const x = col * cellPlusGapX + colFraction * STATE.cellWidth;

            // Y position (account for gap, cell center)
            const cellPlusGapY = STATE.cellHeight + gap;
            const y = row * cellPlusGapY + STATE.cellHeight / 2;

            return {
                x: Math.max(0, Math.min(x, STATE.gridWidth)),
                y: Math.max(STATE.cellHeight / 2, Math.min(y, STATE.gridHeight - STATE.cellHeight / 2))
            };
        }

        function calculateTimeFromPosition(x, y) {
            // Account for gap
            const gap = STATE.gridGap || 2;
            const cellPlusGap = STATE.cellHeight + gap;

            // Calculate row from Y
            const rowContinuous = y / cellPlusGap;
            const row = Math.max(0, Math.min(Math.floor(rowContinuous), STATE.totalRows - 1));

            // Calculate column from X (account for gap)
            const cellPlusGapX = STATE.cellWidth + gap;
            const colContinuous = x / cellPlusGapX;
            const col = Math.max(0, Math.min(Math.floor(colContinuous), CONFIG.columns - 1));
            const xInCol = x - col * cellPlusGapX;
            const colFraction = Math.max(0, Math.min(xInCol / STATE.cellWidth, 1));

            // Calculate continuous cell index
            const continuousCellIndex = row * CONFIG.columns + col + colFraction;
            const timestamp = continuousCellIndex * CONFIG.secondsPerCell;

            return Math.max(0, Math.min(timestamp, CONFIG.videoDuration));
        }

        function moveToCell(col, row) {
            col = Math.max(0, col);
            row = Math.max(0, row);

            const cellIndex = row * CONFIG.columns + col;
            const lastIndex = STATE.totalCells - 1;

            if (cellIndex > lastIndex) {
                row = Math.floor(lastIndex / CONFIG.columns);
                col = lastIndex % CONFIG.columns;
            }

            STATE.currentCellX = col;
            STATE.currentCellY = row;

            const x = col * STATE.cellWidth;
            const y = (row + 0.5) * STATE.cellHeight;
            moveMarkerTo(x, y, true);

            const time = (row * CONFIG.columns + col) * CONFIG.secondsPerCell;
            elements.videoPlayer.currentTime = Math.min(time, CONFIG.videoDuration);
            updateDisplay();
            scrollToMarker();
        }

        function scrollToMarker() {
            const container = elements.gridContainer;
            const markerTop = STATE.markerY;
            const viewportHeight = container.clientHeight;
            const scrollTop = container.scrollTop;

            if (markerTop < scrollTop + 50) {
                container.scrollTo({ top: Math.max(0, markerTop - 100), behavior: 'smooth' });
            } else if (markerTop > scrollTop + viewportHeight - 50) {
                container.scrollTo({ top: markerTop - viewportHeight + 100, behavior: 'smooth' });
            }
        }

        // ==================================================
        // Display Update
        // ==================================================

        function updateDisplay() {
            const time = elements.videoPlayer.currentTime;
            elements.currentTime.textContent = formatTime(time);
            elements.overlayTime.textContent = formatTime(time);
            elements.overlayCell.textContent = `(${STATE.currentCellX}, ${STATE.currentCellY})`;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 100);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }

        function formatTimeShort(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function showLoading(text) {
            elements.loadingText.textContent = text;
            elements.loadingOverlay.classList.add('visible');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.remove('visible');
        }

        // ==================================================
        // Events
        // ==================================================

        function setupEvents() {
            // Grid panel toggle
            elements.gridToggle.addEventListener('click', () => {
                const isCollapsed = elements.gridPanel.classList.toggle('collapsed');
                elements.gridToggle.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
                // Recalculate grid dimensions
                if (!isCollapsed && STATE.currentVideoUrl) {
                    setTimeout(updateGridDimensions, 350);
                }
            });

            // Left panel toggle
            elements.leftPanelToggle.addEventListener('click', () => {
                const isCollapsed = elements.leftPanel.classList.toggle('collapsed');
                elements.leftPanelToggle.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
            });

            // File selection
            elements.uploadDropzone.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', e => {
                if (e.target.files[0]) handleFileSelect(e.target.files[0]);
            });

            // Drag and drop
            elements.uploadDropzone.addEventListener('dragover', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.add('dragover');
            });
            elements.uploadDropzone.addEventListener('dragleave', () => {
                elements.uploadDropzone.classList.remove('dragover');
            });
            elements.uploadDropzone.addEventListener('drop', e => {
                e.preventDefault();
                elements.uploadDropzone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) handleFileSelect(e.dataTransfer.files[0]);
            });

            // Playback controls
            elements.playBtn.addEventListener('click', () => {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                    elements.playBtn.textContent = '‚è∏ ÂÅúÊ≠¢';
                } else {
                    elements.videoPlayer.pause();
                    elements.playBtn.textContent = '‚ñ∂ ÂÜçÁîü';
                }
            });

            // Video events
            let lastScrollTime = 0;
            elements.videoPlayer.addEventListener('timeupdate', () => {
                if (!STATE.isDragging) {
                    const pos = calculateMarkerPositionFromTime(elements.videoPlayer.currentTime);
                    moveMarkerTo(pos.x, pos.y, true);
                    updateDisplay();

                    // Auto-scroll to marker (throttled to 500ms)
                    const now = Date.now();
                    if (now - lastScrollTime > 500) {
                        scrollToMarker();
                        lastScrollTime = now;
                    }
                }
            });

            elements.videoPlayer.addEventListener('play', () => {
                elements.playBtn.textContent = '‚è∏ ÂÅúÊ≠¢';
            });

            elements.videoPlayer.addEventListener('pause', () => {
                elements.playBtn.textContent = '‚ñ∂ ÂÜçÁîü';
            });

            // Grid settings
            elements.regenerateBtn.addEventListener('click', generateThumbnails);
            elements.columnsSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });
            elements.intervalSelect.addEventListener('change', () => {
                if (STATE.currentVideoUrl) generateThumbnails();
            });

            // Grid interaction (mouse)
            const grid = elements.thumbnailGrid;

            grid.addEventListener('mousedown', e => {
                e.preventDefault();
                STATE.isDragging = true;
                handleGridInteraction(e.clientX, e.clientY);
            });

            document.addEventListener('mousemove', e => {
                if (STATE.isDragging) handleGridInteraction(e.clientX, e.clientY);
            });

            document.addEventListener('mouseup', () => {
                if (STATE.isDragging) {
                    STATE.isDragging = false;
                    scrollToMarker();
                }
            });

            // Grid interaction (touch)
            grid.addEventListener('touchstart', e => {
                e.preventDefault();
                STATE.isDragging = true;
                const touch = e.touches[0];
                handleGridInteraction(touch.clientX, touch.clientY);
            }, { passive: false });

            grid.addEventListener('touchmove', e => {
                if (STATE.isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    handleGridInteraction(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            grid.addEventListener('touchend', () => {
                if (STATE.isDragging) {
                    STATE.isDragging = false;
                    scrollToMarker();
                }
            });

            grid.addEventListener('click', handleGridClick);

            // Keyboard
            document.addEventListener('keydown', e => {
                if (!STATE.currentVideoUrl) return;

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        elements.playBtn.click();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX - 1, STATE.currentCellY);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX + 1, STATE.currentCellY);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY - 1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        moveToCell(STATE.currentCellX, STATE.currentCellY + 1);
                        break;
                    case 'Home':
                        e.preventDefault();
                        moveToCell(0, 0);
                        break;
                    case 'End':
                        e.preventDefault();
                        const lastIdx = STATE.totalCells - 1;
                        moveToCell(lastIdx % CONFIG.columns, Math.floor(lastIdx / CONFIG.columns));
                        break;
                }
            });
        }

        function handleGridClick(e) {
            handleGridInteraction(e.clientX, e.clientY);
        }

        function handleGridInteraction(clientX, clientY) {
            const grid = elements.thumbnailGrid;
            const rect = grid.getBoundingClientRect();

            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const clampedX = Math.max(0, Math.min(x, STATE.gridWidth));
            const clampedY = Math.max(0, Math.min(y, STATE.gridHeight));

            moveMarkerTo(clampedX, clampedY, false);

            const time = calculateTimeFromPosition(clampedX, clampedY);

            // Force video frame update when paused
            const video = elements.videoPlayer;
            const wasPaused = video.paused;
            video.currentTime = time;

            // If video is paused, force frame render by briefly playing
            if (wasPaused && video.readyState >= 2) {
                video.play().then(() => {
                    video.pause();
                }).catch(() => {
                    // Ignore autoplay restrictions
                });
            }

            STATE.currentCellX = Math.floor(clampedX / STATE.cellWidth);
            STATE.currentCellY = Math.floor(clampedY / STATE.cellHeight);

            updateDisplay();
        }

        // ==================================================
        // Initialize
        // ==================================================

        setupEvents();
    </script>
</body>
</html>
